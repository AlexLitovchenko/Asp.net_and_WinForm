Модель EF хранит сведения о сопоставлении классов и свойств приложений с таблицами и столбцами баз данных. Модель EF можно создать двумя способами.
С помощью Code First: 
	разработчик пишет код, чтобы указать модель. 
	Во время выполнения EF создает модели и сопоставления на основе классов сущностей и дополнительной конфигурации модели, предоставленных разработчиком.
С помощью Entity Framework Designer: 
	разработчик рисует поля и строки для указания модели с помощью Entity Framework Designer. 
	Результирующая модель хранится в виде XML-файла с расширением EDMX. 
	Объекты предметной области приложения обычно создаются автоматически на основе концептуальной модели.

Model-First:
	Как было сказано ранее, подход к проектированию Model-First позволяет создать сначала графическую модель с помощью дизайнера EDM среды Visual Studio, а уже затем на ее основе создать базу данных. 
	При подходе Model-First мы сначала создаем графическую модель, а затем на ее основе генерируем или изменяем базу данных.

Database First:
	Database First был первым подходом, который появился в Entity Framework. 
	Данный подход во многом похож на Model First и подходит для тех случаев, когда разработчик уже имеет готовую базу данных.
	Подход Database-First подразумевает создание графической модели Edmx из существующей базы данных. 
	Первым шагом при работе с подходом Database-First является проектирование базы данных. 
	Фактически подход Database-First является противоположным подходу Model-First.
	При подходе Database-First мы сначала создаем и проектируем базу данных, а затем на ее основе создаем графическую модель.

Code First Migrations — это рекомендуемый способ разработки структуры базы данных в приложении при использовании рабочего процесса Code First. 
Code First Migrations предоставляет набор средств со следующими функциями:
		1. Создание исходной базы данных, которая работает с моделью EF.
		2. Создание миграций для отслеживания изменений в модели EF.
		3. Поддержание актуальности базы данных с учетом этих изменений.

Запустите команду Enable-Migrations в консоли диспетчера пакетов.
В результате этой команды в проект будет добавлена папка Migrations. В новой папке два файла:
		1.  Класс конфигурации. 
			Этот класс позволяет настраивать поведение миграций для контекста. 
			В этом пошаговом руководстве мы будем просто использовать конфигурацию по умолчанию. 
			Поскольку имеется только один контекст Code First в проекте, Enable-Migrations автоматически заполняет тип контекста, к которому относится эта конфигурация.
		2.  Миграция InitialCreate. 
			Эта миграция создана, так как мы уже использовали Code First для создания базы данных, прежде чем включили миграции. 
			Код в этой созданной по шаблону миграции представляет объекты, которые уже были созданы в базе данных. 
			Имя файла содержит метку времени для удобства упорядочения. 
			Если бы база данных еще не была создана, миграция InitialCreate не была бы добавлена в проект. 
			Вместо этого, когда мы впервые вызвали бы Add-Migration, код для создания этих таблиц был бы перенесен в новую миграцию.

Создание и запуск миграци.
Вам нужно знать о двух основных командах Code First Migrations.
		1. Add-Migration будет автоматически формировать следующую миграцию на основе изменений, внесенных в модель с момента создания последней миграции.
		2. Update-Database будет применять ожидающие обработки миграции к базе данных.

Консоль диспетчера пакетов:
	Для того, чтобы физически создать базу данных нужно прописать команду:
	Add-Migration InitialCreare -OutputDir "Storage/Migrations"
	Пояснение: Add-Migration имя_авто_класса -OutputDir "куда_хотим_поместить_класс"

	Чтоб база данных появилась нужно прописать команду:
	Update-Database -Context HospitalDataContext

Работа с DbContext
	Чтобы использовать Entity Framework для запроса, вставки, обновления и удаления данных с помощью объектов .NET, необходимо сначала создать модель , 
	которая сопоставляет сущности и связи, определенные в модели, с таблицами в базе данных.
	После создания модели основной класс, с которым взаимодействует приложение, является System.Data.Entity.DbContext (часто называется классом контекста). 
	DbContext, связанный с моделью, можно использовать для:
		1. Создание и выполнение запросов
		2. Материализация результатов запросов в виде объектов сущностей
        3. Отслеживание изменений, внесенных в эти объекты
		4. Сохранить изменения объекта обратно в базе данных
		5. Привязка объектов в памяти к элементам управления пользовательского интерфейса

IWebHostEnvironment Interface:
	Предоставляет информацию о среде веб-хостинга, в которой запущено приложение.

Асинхронное программирование:
	Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы или блоки кода.
	Также асинхронность несет выгоды в веб-приложениях при обработке запросов от пользователей, при обращении к базам данных или сетевым ресурсам. 
	При больших запросах к базе данных асинхронный метод просто уснет на время, пока не получит данные от БД, а основной поток сможет продолжить свою работу. 
	В синхронном же приложении, если бы код получения данных находился в основном потоке, этот поток просто бы блокировался на время получения данных.

	Ключевыми для работы с асинхронными вызовами в C# являются два ключевых слова: async и await.
	Они используются вместе для создания асинхронного метода.

Асинхонный метод обладает следующими признаками:
	1. В заголовке метода используется модификатор async
	2. Метод содержит одно или несколько выражений await
	3. В качестве возвращаемого типа используется один из следующих:
		1) void
		2) Task
		3) Task<T>
		4) ValueTask<T>

Асинхронный метод, как и обычный, может использовать любое количество параметров или не использовать их вообще. 
Однако асинхронный метод не может определять параметры с модификаторами out и ref.

Также стоит отметить, что слово async, которое указывается в определении метода, не делает автоматически метод асинхронным. 
Оно лишь указывает, что данный метод может содержать одно или несколько выражений await.

Использование типа ValueTask<T> во многом аналогично применению Task<T> за исключением некоторых различий в работе с памятью, поскольку ValueTask - структура, а Task - класс.

Первичный и внешний ключи sql.
	внешний ключ SQL — это ключ, используемый для объединения двух таблиц. 
	Иногда его также называют ссылочным ключом. 
	Внешний ключ — это столбец или комбинация столбцов, значения которых соответствуют Первичному ключу в другой таблице.

	Связь между двумя таблицами задается через соответствие Первичного ключа в одной из таблиц внешнему ключу во второй. 
	Если для таблицы первичный ключ задан в определенном поле, то в этом поле не может содержаться двух записей с одинаковыми значениями.
	Как вы понимаете, Code-First использует определенные соглашения при поиске внешнего ключа в свойствах модели. 

	Эти правила основаны на имени свойства и придерживаются следующих шаблонов:
		1. [Имя первичного ключа внешней таблицы]
		2. [Имя внешней таблицы] + [Имя первичного ключа внешней таблицы]
		3. [Имя навигационного свойства] + [Имя первичного ключа внешней таблицы]

	Также стоит отметить, что Code-First не чувствителен к регистру символов при поиске внешнего ключа

Отношения между моделями 
1) Один к одному
	Отношение один к одному предполагает, что главная сущность может ссылаться только на один объект зависимой сущности. 
	В свою очередь, зависимая сущность может ссылаться только на один объект главной сущности.
2) Один ко многим
	Связь один-ко-многим (one-to-many) представляет ситуацию, когда одна модель хранит ссылку на один объект другой модели, а вторая модель может ссылаться на коллекцию объектов первой модели. 
	Например, в одной компании может работать несколько сотрудников, а каждый сотрудник в свою очередь может официально работать только в одной компании
3) Многие ко многим
	Примером подобного отношения может служить посещение студентами университетских курсов. 
	Один студент может посещать сразу несколько курсов, и, в свою очередь, один курс может посещаться множеством студентов.

Сопоставление типоы SQL Server и С#
	int : int
	bit : bool
	char : string
	date : DateTime
	datetime : DateTime
	datetime2 : DateTime
	decimal : decimal
	float : double
	money : decimal
	nchar : string
	ntext : string
	numeric : decimal
	nvarchar : string
	real : float
	smallint : short
	text : string
	tinyint : byte
	varchar : string


Метод AsNoTracking()
	Когда контекст данных извлекает данные из базы данных, 
	Entity Framework помещает извлеченные объекты в кэш и отслеживает изменения, 
	которые происходят с этими объектами вплоть до использования метода SaveChanges(), 
	который фиксирует все изменения в базе данных. 
	Но нам не всегда необходимо отслеживать изменения. Например, нам надо просто вывести данные для просмотра.

	Чтобы данные не помещались в кэш, применяется метод AsNoTracking(). 
	При его применении возвращаемые из запроса данные не кэшируются. 
	А это означает, что Entity Framework не производит какую-то дополнительную обработку и не выделяет дополнительное место для хранения извлеченных из БД объектов.

Метод FirstOrDefaultAsync()
	Асинхронно возвращает первый элемент последовательности или значение по умолчанию, если последовательность не содержит элементов.


Тип DateTime:
	DateTime date1 = new DateTime(2015, 7, 20, 18, 30, 25);
	Console.WriteLine(date1.ToLocalTime());        // 20.07.2015 21:30:25
	Console.WriteLine(date1.ToUniversalTime());    // 20.07.2015 15:30:25
	Console.WriteLine(date1.ToLongDateString());   // 20 июля 2015 г.
	Console.WriteLine(date1.ToShortDateString());  // 20.07.2015
	Console.WriteLine(date1.ToLongTimeString());   // 18:30:25
	Console.WriteLine(date1.ToShortTimeString());  // 18:30

	Для добавления дат используется ряд методов:
		Add(DateTime date):			добавляет дату date
		AddDays(double value):		добавляет к текущей дате несколько дней
		AddHours(double value):		добавляет к текущей дате несколько часов
		AddMinutes(double value):	добавляет к текущей дате несколько минут
		AddMonths(int value):		добавляет к текущей дате несколько месяцев
		AddYears(int value):		добавляет к текущей дате несколько лет

TempDate:
	TempData в ASP.NET MVC может использоваться для хранения временных данных, которые можно использовать в последующем запросе.
	TempData будет очищен после завершения последующего запроса.

	TempData полезна, когда вы хотите перенести нечувствительные данные из одного метода действия в другой метод действия того же или другого контроллера, а также перенаправления. 
	Это тип словаря, который является производным от TempDataDictionary.

	1. TempData может использоваться для хранения данных между двумя последовательными запросами. Значения TempData будут сохранены во время перенаправления.
	2. TemData - это тип TempDataDictionary.
	3. TempData использует Session для хранения данных. Так что думайте об этом как о недолгой сессии.
	4. Значение TempData должно быть приведено к типу перед использованием. Проверьте на нулевые значения, чтобы избежать ошибки во время выполнения.
	5. TempData может использоваться для хранения только однократных сообщений, таких как сообщения об ошибках, сообщения проверки.
	6. Вызовите TempData.Keep (), чтобы сохранить все значения TempData в третьем запросе.